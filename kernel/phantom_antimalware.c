/*
 * ==============================================================================
 *                       PHANTOM ANTI-MALWARE SCANNER
 *                      "To Create, Not To Destroy"
 * ==============================================================================
 *
 * Implementation of the PhantomOS Anti-Malware Scanner.
 */

#include "phantom_antimalware.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/inotify.h>
#include <math.h>

/* ─────────────────────────────────────────────────────────────────────────────
 * Internal Constants
 * ───────────────────────────────────────────────────────────────────────────── */

#define INOTIFY_EVENT_SIZE  (sizeof(struct inotify_event))
#define INOTIFY_BUF_LEN     (1024 * (INOTIFY_EVENT_SIZE + 16))

/* Suspicious strings to look for in binaries */
static const char *suspicious_strings[] = {
    /* Shell commands */
    "/bin/sh", "/bin/bash", "/bin/zsh",
    "system(", "popen(", "exec(",

    /* Network */
    "socket(", "connect(", "bind(",
    "SOCK_STREAM", "SOCK_RAW",
    "wget ", "curl ", "nc ",

    /* Persistence */
    "/etc/cron", "crontab", ".bashrc", ".profile",
    "systemctl", "init.d", "rc.local",

    /* Credential theft */
    "/etc/passwd", "/etc/shadow",
    ".ssh/", "id_rsa", "authorized_keys",
    "password", "credential",

    /* Crypto indicators */
    "YOUR FILES HAVE BEEN ENCRYPTED",
    "bitcoin", "monero", "ransom",
    ".onion", "tor2web",

    /* Anti-analysis */
    "ptrace", "PTRACE_TRACEME",
    "/proc/self", "LD_PRELOAD",
    "VirtualBox", "VMware", "QEMU",

    /* Keylogging */
    "XOpenDisplay", "XQueryKeymap",
    "GetAsyncKeyState", "keylog",

    /* Screen capture */
    "screenshot", "XGetImage",

    NULL
};

/* Suspicious ELF imports */
static const char *suspicious_imports[] = {
    "ptrace", "dlopen", "dlsym",
    "mprotect", "mmap",
    "fork", "execve", "execvp",
    "socket", "connect", "bind", "listen",
    "getenv", "setenv", "putenv",
    "unlink", "remove", "rmdir",
    "chmod", "chown", "setuid", "setgid",
    "kill", "signal",
    NULL
};

/* ─────────────────────────────────────────────────────────────────────────────
 * Magic Bytes for File Type Detection
 * ───────────────────────────────────────────────────────────────────────────── */

typedef struct {
    const uint8_t *magic;
    size_t magic_len;
    antimalware_filetype_t type;
} magic_entry_t;

static const uint8_t MAGIC_ELF[] = {0x7f, 'E', 'L', 'F'};
static const uint8_t MAGIC_PE[] = {'M', 'Z'};
static const uint8_t MAGIC_MACHO32[] = {0xfe, 0xed, 0xfa, 0xce};
static const uint8_t MAGIC_MACHO64[] = {0xfe, 0xed, 0xfa, 0xcf};
static const uint8_t MAGIC_PDF[] = {'%', 'P', 'D', 'F'};
static const uint8_t MAGIC_ZIP[] = {'P', 'K', 0x03, 0x04};
static const uint8_t MAGIC_GZIP[] = {0x1f, 0x8b};
static const uint8_t MAGIC_RAR[] = {'R', 'a', 'r', '!'};
static const uint8_t MAGIC_7ZIP[] = {'7', 'z', 0xbc, 0xaf};
static const uint8_t MAGIC_DOC[] = {0xd0, 0xcf, 0x11, 0xe0};
static const uint8_t MAGIC_PNG[] = {0x89, 'P', 'N', 'G'};
static const uint8_t MAGIC_JPG[] = {0xff, 0xd8, 0xff};
static const uint8_t MAGIC_GIF[] = {'G', 'I', 'F', '8'};
static const uint8_t MAGIC_TAR[] = {'u', 's', 't', 'a', 'r'};

static const magic_entry_t magic_table[] = {
    {MAGIC_ELF, 4, FILETYPE_ELF},
    {MAGIC_PE, 2, FILETYPE_PE},
    {MAGIC_MACHO32, 4, FILETYPE_MACHO},
    {MAGIC_MACHO64, 4, FILETYPE_MACHO},
    {MAGIC_PDF, 4, FILETYPE_PDF},
    {MAGIC_ZIP, 4, FILETYPE_ZIP},
    {MAGIC_GZIP, 2, FILETYPE_GZIP},
    {MAGIC_RAR, 4, FILETYPE_RAR},
    {MAGIC_7ZIP, 4, FILETYPE_7ZIP},
    {MAGIC_DOC, 4, FILETYPE_OFFICE_DOC},
    {MAGIC_PNG, 4, FILETYPE_IMAGE},
    {MAGIC_JPG, 3, FILETYPE_IMAGE},
    {MAGIC_GIF, 4, FILETYPE_IMAGE},
    {NULL, 0, FILETYPE_UNKNOWN}
};

/* ─────────────────────────────────────────────────────────────────────────────
 * Simple SHA-256 Implementation (for systems without OpenSSL)
 * ───────────────────────────────────────────────────────────────────────────── */

typedef struct {
    uint32_t state[8];
    uint64_t count;
    uint8_t buffer[64];
} sha256_ctx_t;

static const uint32_t sha256_k[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

#define SHA256_ROTR(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
#define SHA256_CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
#define SHA256_MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define SHA256_EP0(x) (SHA256_ROTR(x, 2) ^ SHA256_ROTR(x, 13) ^ SHA256_ROTR(x, 22))
#define SHA256_EP1(x) (SHA256_ROTR(x, 6) ^ SHA256_ROTR(x, 11) ^ SHA256_ROTR(x, 25))
#define SHA256_SIG0(x) (SHA256_ROTR(x, 7) ^ SHA256_ROTR(x, 18) ^ ((x) >> 3))
#define SHA256_SIG1(x) (SHA256_ROTR(x, 17) ^ SHA256_ROTR(x, 19) ^ ((x) >> 10))

static void sha256_init(sha256_ctx_t *ctx) {
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
    ctx->count = 0;
}

static void sha256_transform(sha256_ctx_t *ctx, const uint8_t *data) {
    uint32_t w[64], a, b, c, d, e, f, g, h, t1, t2;
    int i;

    for (i = 0; i < 16; i++) {
        w[i] = ((uint32_t)data[i * 4] << 24) |
               ((uint32_t)data[i * 4 + 1] << 16) |
               ((uint32_t)data[i * 4 + 2] << 8) |
               ((uint32_t)data[i * 4 + 3]);
    }
    for (i = 16; i < 64; i++) {
        w[i] = SHA256_SIG1(w[i - 2]) + w[i - 7] + SHA256_SIG0(w[i - 15]) + w[i - 16];
    }

    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2]; d = ctx->state[3];
    e = ctx->state[4]; f = ctx->state[5]; g = ctx->state[6]; h = ctx->state[7];

    for (i = 0; i < 64; i++) {
        t1 = h + SHA256_EP1(e) + SHA256_CH(e, f, g) + sha256_k[i] + w[i];
        t2 = SHA256_EP0(a) + SHA256_MAJ(a, b, c);
        h = g; g = f; f = e; e = d + t1;
        d = c; c = b; b = a; a = t1 + t2;
    }

    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c; ctx->state[3] += d;
    ctx->state[4] += e; ctx->state[5] += f; ctx->state[6] += g; ctx->state[7] += h;
}

static void sha256_update(sha256_ctx_t *ctx, const uint8_t *data, size_t len) {
    size_t i, idx = ctx->count % 64;
    ctx->count += len;

    for (i = 0; i < len; i++) {
        ctx->buffer[idx++] = data[i];
        if (idx == 64) {
            sha256_transform(ctx, ctx->buffer);
            idx = 0;
        }
    }
}

static void sha256_final(sha256_ctx_t *ctx, uint8_t *hash) {
    uint8_t pad[64] = {0x80};
    uint64_t bits = ctx->count * 8;
    size_t idx = ctx->count % 64;
    size_t pad_len = (idx < 56) ? (56 - idx) : (120 - idx);
    int i;

    sha256_update(ctx, pad, pad_len);

    for (i = 7; i >= 0; i--) {
        ctx->buffer[56 + (7 - i)] = (bits >> (i * 8)) & 0xff;
    }
    sha256_transform(ctx, ctx->buffer);

    for (i = 0; i < 8; i++) {
        hash[i * 4] = (ctx->state[i] >> 24) & 0xff;
        hash[i * 4 + 1] = (ctx->state[i] >> 16) & 0xff;
        hash[i * 4 + 2] = (ctx->state[i] >> 8) & 0xff;
        hash[i * 4 + 3] = ctx->state[i] & 0xff;
    }
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Simple MD5 Implementation
 * ───────────────────────────────────────────────────────────────────────────── */

typedef struct {
    uint32_t state[4];
    uint64_t count;
    uint8_t buffer[64];
} md5_ctx_t;

#define MD5_F(x, y, z) (((x) & (y)) | (~(x) & (z)))
#define MD5_G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
#define MD5_H(x, y, z) ((x) ^ (y) ^ (z))
#define MD5_I(x, y, z) ((y) ^ ((x) | ~(z)))
#define MD5_ROTL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

static const uint32_t md5_t[64] = {
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
};

static const uint8_t md5_s[64] = {
    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
};

static void md5_init(md5_ctx_t *ctx) {
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xefcdab89;
    ctx->state[2] = 0x98badcfe;
    ctx->state[3] = 0x10325476;
    ctx->count = 0;
}

static void md5_transform(md5_ctx_t *ctx, const uint8_t *data) {
    uint32_t w[16], a, b, c, d, f, g, temp;
    int i;

    for (i = 0; i < 16; i++) {
        w[i] = ((uint32_t)data[i * 4]) |
               ((uint32_t)data[i * 4 + 1] << 8) |
               ((uint32_t)data[i * 4 + 2] << 16) |
               ((uint32_t)data[i * 4 + 3] << 24);
    }

    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2]; d = ctx->state[3];

    for (i = 0; i < 64; i++) {
        if (i < 16) {
            f = MD5_F(b, c, d);
            g = i;
        } else if (i < 32) {
            f = MD5_G(b, c, d);
            g = (5 * i + 1) % 16;
        } else if (i < 48) {
            f = MD5_H(b, c, d);
            g = (3 * i + 5) % 16;
        } else {
            f = MD5_I(b, c, d);
            g = (7 * i) % 16;
        }
        temp = d;
        d = c;
        c = b;
        b = b + MD5_ROTL((a + f + md5_t[i] + w[g]), md5_s[i]);
        a = temp;
    }

    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c; ctx->state[3] += d;
}

static void md5_update(md5_ctx_t *ctx, const uint8_t *data, size_t len) {
    size_t i, idx = ctx->count % 64;
    ctx->count += len;

    for (i = 0; i < len; i++) {
        ctx->buffer[idx++] = data[i];
        if (idx == 64) {
            md5_transform(ctx, ctx->buffer);
            idx = 0;
        }
    }
}

static void md5_final(md5_ctx_t *ctx, uint8_t *hash) {
    uint8_t pad[64] = {0x80};
    uint64_t bits = ctx->count * 8;
    size_t idx = ctx->count % 64;
    size_t pad_len = (idx < 56) ? (56 - idx) : (120 - idx);
    int i;

    md5_update(ctx, pad, pad_len);

    for (i = 0; i < 8; i++) {
        ctx->buffer[56 + i] = (bits >> (i * 8)) & 0xff;
    }
    md5_transform(ctx, ctx->buffer);

    for (i = 0; i < 4; i++) {
        hash[i * 4] = ctx->state[i] & 0xff;
        hash[i * 4 + 1] = (ctx->state[i] >> 8) & 0xff;
        hash[i * 4 + 2] = (ctx->state[i] >> 16) & 0xff;
        hash[i * 4 + 3] = (ctx->state[i] >> 24) & 0xff;
    }
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Hash Utility Functions
 * ───────────────────────────────────────────────────────────────────────────── */

static void bytes_to_hex(const uint8_t *bytes, size_t len, char *hex_out) {
    const char *hex_chars = "0123456789abcdef";
    size_t i;
    for (i = 0; i < len; i++) {
        hex_out[i * 2] = hex_chars[(bytes[i] >> 4) & 0x0f];
        hex_out[i * 2 + 1] = hex_chars[bytes[i] & 0x0f];
    }
    hex_out[len * 2] = '\0';
}

void phantom_antimalware_hash_data_md5(const uint8_t *data, size_t size, char *hash_out) {
    md5_ctx_t ctx;
    uint8_t hash[16];

    md5_init(&ctx);
    md5_update(&ctx, data, size);
    md5_final(&ctx, hash);
    bytes_to_hex(hash, 16, hash_out);
}

void phantom_antimalware_hash_data_sha256(const uint8_t *data, size_t size, char *hash_out) {
    sha256_ctx_t ctx;
    uint8_t hash[32];

    sha256_init(&ctx);
    sha256_update(&ctx, data, size);
    sha256_final(&ctx, hash);
    bytes_to_hex(hash, 32, hash_out);
}

int phantom_antimalware_hash_file_md5(const char *filepath, char *hash_out) {
    FILE *fp;
    md5_ctx_t ctx;
    uint8_t buffer[8192];
    uint8_t hash[16];
    size_t bytes_read;

    fp = fopen(filepath, "rb");
    if (!fp) return -1;

    md5_init(&ctx);
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), fp)) > 0) {
        md5_update(&ctx, buffer, bytes_read);
    }
    fclose(fp);

    md5_final(&ctx, hash);
    bytes_to_hex(hash, 16, hash_out);
    return 0;
}

int phantom_antimalware_hash_file_sha256(const char *filepath, char *hash_out) {
    FILE *fp;
    sha256_ctx_t ctx;
    uint8_t buffer[8192];
    uint8_t hash[32];
    size_t bytes_read;

    fp = fopen(filepath, "rb");
    if (!fp) return -1;

    sha256_init(&ctx);
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), fp)) > 0) {
        sha256_update(&ctx, buffer, bytes_read);
    }
    fclose(fp);

    sha256_final(&ctx, hash);
    bytes_to_hex(hash, 32, hash_out);
    return 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * DJB2 Hash for Signature Lookup
 * ───────────────────────────────────────────────────────────────────────────── */

static uint32_t djb2_hash(const char *str) {
    uint32_t hash = 5381;
    int c;
    while ((c = (unsigned char)*str++)) {
        hash = ((hash << 5) + hash) + c;
    }
    return hash;
}

static uint32_t hash_to_bucket(const char *hash_sha256) {
    return djb2_hash(hash_sha256) % ANTIMALWARE_HASH_BUCKETS;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Core API Implementation
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_init(phantom_antimalware_t *scanner) {
    if (!scanner) return -1;

    memset(scanner, 0, sizeof(phantom_antimalware_t));

    /* Initialize hash table */
    memset(scanner->signature_table, 0, sizeof(scanner->signature_table));

    /* Initialize mutexes */
    pthread_mutex_init(&scanner->quarantine_lock, NULL);
    pthread_mutex_init(&scanner->monitor_lock, NULL);

    /* Set default quarantine path */
    snprintf(scanner->quarantine_path, sizeof(scanner->quarantine_path),
             "/var/phantom/quarantine");

    /* Set default scan options */
    scanner->default_options.scan_archives = 0;
    scanner->default_options.scan_hidden = 1;
    scanner->default_options.recursive = 1;
    scanner->default_options.heuristics_enabled = 1;
    scanner->default_options.max_depth = 50;
    scanner->default_options.max_file_size = ANTIMALWARE_MAX_SCAN_SIZE;
    scanner->default_options.quick_scan = 0;
    scanner->default_options.follow_symlinks = 0;

    scanner->inotify_fd = -1;
    scanner->initialized = 1;

    return 0;
}

void phantom_antimalware_shutdown(phantom_antimalware_t *scanner) {
    if (!scanner || !scanner->initialized) return;

    /* Stop real-time monitoring if active */
    if (scanner->realtime_enabled) {
        phantom_antimalware_stop_realtime(scanner);
    }

    /* Clear signatures */
    phantom_antimalware_clear_signatures(scanner);

    /* Clear exclusions */
    phantom_antimalware_clear_exclusions(scanner);

    /* Free quarantine list */
    antimalware_quarantine_entry_t *q = scanner->quarantine_list;
    while (q) {
        antimalware_quarantine_entry_t *next = q->next;
        free(q);
        q = next;
    }

    /* Destroy mutexes */
    pthread_mutex_destroy(&scanner->quarantine_lock);
    pthread_mutex_destroy(&scanner->monitor_lock);

    scanner->initialized = 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Signature Database Functions
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_add_signature(phantom_antimalware_t *scanner,
                                       const char *hash_sha256,
                                       const char *threat_name,
                                       antimalware_threat_t threat_type) {
    if (!scanner || !hash_sha256 || !threat_name) return -1;
    if (strlen(hash_sha256) != 64) return -1;  /* SHA256 = 64 hex chars */

    antimalware_signature_t *sig = malloc(sizeof(antimalware_signature_t));
    if (!sig) return -1;

    strncpy(sig->hash_sha256, hash_sha256, sizeof(sig->hash_sha256) - 1);
    sig->hash_sha256[sizeof(sig->hash_sha256) - 1] = '\0';

    /* Convert first 8 hex chars to hash prefix */
    char prefix_hex[9];
    strncpy(prefix_hex, hash_sha256, 8);
    prefix_hex[8] = '\0';
    sig->hash_prefix = (uint32_t)strtoul(prefix_hex, NULL, 16);

    strncpy(sig->threat_name, threat_name, sizeof(sig->threat_name) - 1);
    sig->threat_name[sizeof(sig->threat_name) - 1] = '\0';
    sig->threat_type = threat_type;

    /* Add to hash table */
    uint32_t bucket = hash_to_bucket(hash_sha256);
    sig->next = scanner->signature_table[bucket];
    scanner->signature_table[bucket] = sig;
    scanner->signature_count++;

    return 0;
}

int phantom_antimalware_load_signatures(phantom_antimalware_t *scanner,
                                         const char *filepath) {
    if (!scanner || !filepath) return -1;

    FILE *fp = fopen(filepath, "r");
    if (!fp) return -1;

    char line[512];
    int loaded = 0;

    while (fgets(line, sizeof(line), fp)) {
        /* Skip comments and empty lines */
        char *p = line;
        while (*p && isspace(*p)) p++;
        if (!*p || *p == '#') continue;

        /* Remove newline */
        size_t len = strlen(p);
        if (len > 0 && p[len - 1] == '\n') p[len - 1] = '\0';

        /* Format: SHA256:TYPE:NAME */
        char *hash = p;
        char *colon1 = strchr(hash, ':');
        if (!colon1) continue;
        *colon1 = '\0';

        char *type_str = colon1 + 1;
        char *colon2 = strchr(type_str, ':');
        if (!colon2) continue;
        *colon2 = '\0';

        char *name = colon2 + 1;

        /* Parse threat type */
        antimalware_threat_t threat_type = THREAT_MALWARE;
        int type_num = atoi(type_str);
        if (type_num >= 0 && type_num <= THREAT_BACKDOOR) {
            threat_type = (antimalware_threat_t)type_num;
        }

        if (phantom_antimalware_add_signature(scanner, hash, name, threat_type) == 0) {
            loaded++;
        }
    }

    fclose(fp);
    return loaded;
}

int phantom_antimalware_load_signature_dir(phantom_antimalware_t *scanner,
                                            const char *dirpath) {
    if (!scanner || !dirpath) return -1;

    DIR *dir = opendir(dirpath);
    if (!dir) return -1;

    struct dirent *entry;
    int total_loaded = 0;
    char filepath[ANTIMALWARE_MAX_PATH];

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_name[0] == '.') continue;

        /* Check for .sig or .signatures extension */
        const char *ext = strrchr(entry->d_name, '.');
        if (!ext) continue;
        if (strcmp(ext, ".sig") != 0 && strcmp(ext, ".signatures") != 0) continue;

        snprintf(filepath, sizeof(filepath), "%s/%s", dirpath, entry->d_name);

        int loaded = phantom_antimalware_load_signatures(scanner, filepath);
        if (loaded > 0) {
            total_loaded += loaded;
        }
    }

    closedir(dir);
    return total_loaded;
}

antimalware_signature_t *phantom_antimalware_lookup_hash(
    phantom_antimalware_t *scanner, const char *hash_sha256) {
    if (!scanner || !hash_sha256 || strlen(hash_sha256) != 64) return NULL;

    uint32_t bucket = hash_to_bucket(hash_sha256);
    antimalware_signature_t *sig = scanner->signature_table[bucket];

    while (sig) {
        if (strcasecmp(sig->hash_sha256, hash_sha256) == 0) {
            return sig;
        }
        sig = sig->next;
    }
    return NULL;
}

uint32_t phantom_antimalware_get_signature_count(phantom_antimalware_t *scanner) {
    return scanner ? scanner->signature_count : 0;
}

void phantom_antimalware_clear_signatures(phantom_antimalware_t *scanner) {
    if (!scanner) return;

    for (int i = 0; i < ANTIMALWARE_HASH_BUCKETS; i++) {
        antimalware_signature_t *sig = scanner->signature_table[i];
        while (sig) {
            antimalware_signature_t *next = sig->next;
            free(sig);
            sig = next;
        }
        scanner->signature_table[i] = NULL;
    }
    scanner->signature_count = 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * File Type Detection
 * ───────────────────────────────────────────────────────────────────────────── */

antimalware_filetype_t phantom_antimalware_detect_filetype(
    const uint8_t *data, size_t size, const char *filename) {

    if (!data || size < 4) {
        /* Try to determine from extension */
        if (filename) {
            const char *ext = strrchr(filename, '.');
            if (ext) {
                if (strcasecmp(ext, ".sh") == 0) return FILETYPE_SCRIPT_SHELL;
                if (strcasecmp(ext, ".py") == 0) return FILETYPE_SCRIPT_PYTHON;
                if (strcasecmp(ext, ".pl") == 0) return FILETYPE_SCRIPT_PERL;
                if (strcasecmp(ext, ".php") == 0) return FILETYPE_SCRIPT_PHP;
                if (strcasecmp(ext, ".js") == 0) return FILETYPE_SCRIPT_JS;
                if (strcasecmp(ext, ".html") == 0 || strcasecmp(ext, ".htm") == 0) return FILETYPE_HTML;
                if (strcasecmp(ext, ".xml") == 0) return FILETYPE_XML;
                if (strcasecmp(ext, ".json") == 0) return FILETYPE_JSON;
                if (strcasecmp(ext, ".txt") == 0) return FILETYPE_TEXT;
            }
        }
        return FILETYPE_UNKNOWN;
    }

    /* Check magic bytes */
    for (int i = 0; magic_table[i].magic != NULL; i++) {
        if (size >= magic_table[i].magic_len &&
            memcmp(data, magic_table[i].magic, magic_table[i].magic_len) == 0) {
            return magic_table[i].type;
        }
    }

    /* Check for script shebangs */
    if (size >= 2 && data[0] == '#' && data[1] == '!') {
        if (size >= 10) {
            if (strstr((const char *)data, "/bin/sh") ||
                strstr((const char *)data, "/bin/bash")) {
                return FILETYPE_SCRIPT_SHELL;
            }
            if (strstr((const char *)data, "python")) {
                return FILETYPE_SCRIPT_PYTHON;
            }
            if (strstr((const char *)data, "perl")) {
                return FILETYPE_SCRIPT_PERL;
            }
        }
        return FILETYPE_SCRIPT_SHELL;  /* Default shebang */
    }

    /* Check for TAR (offset 257) */
    if (size >= 262 && memcmp(data + 257, MAGIC_TAR, 5) == 0) {
        return FILETYPE_TAR;
    }

    /* Check for text/script content */
    if (size >= 5) {
        if (memcmp(data, "<?php", 5) == 0) return FILETYPE_SCRIPT_PHP;
        if (memcmp(data, "<?xml", 5) == 0) return FILETYPE_XML;
        if (memcmp(data, "<html", 5) == 0 || memcmp(data, "<!DOC", 5) == 0) return FILETYPE_HTML;
    }

    return FILETYPE_UNKNOWN;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Entropy Calculation
 * ───────────────────────────────────────────────────────────────────────────── */

double phantom_antimalware_calculate_entropy(const uint8_t *data, size_t size) {
    if (!data || size == 0) return 0.0;

    uint64_t freq[256] = {0};
    double entropy = 0.0;

    /* Count byte frequencies */
    for (size_t i = 0; i < size; i++) {
        freq[data[i]]++;
    }

    /* Calculate Shannon entropy */
    for (int i = 0; i < 256; i++) {
        if (freq[i] > 0) {
            double p = (double)freq[i] / (double)size;
            entropy -= p * log2(p);
        }
    }

    return entropy;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * String Checking
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_check_strings(const uint8_t *data, size_t size,
                                       antimalware_scan_result_t *result) {
    if (!data || size == 0 || !result) return 0;

    int count = 0;
    char str_buffer[size + 1];
    memcpy(str_buffer, data, size);
    str_buffer[size] = '\0';

    for (int i = 0; suspicious_strings[i] != NULL; i++) {
        if (strstr(str_buffer, suspicious_strings[i])) {
            count++;
        }
    }

    result->suspicious_strings_count = count;
    return count;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * ELF Import Checking
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_check_elf_imports(const uint8_t *data, size_t size,
                                           antimalware_scan_result_t *result) {
    if (!data || size < 64 || !result) return 0;

    /* Verify ELF magic */
    if (memcmp(data, MAGIC_ELF, 4) != 0) return 0;

    int count = 0;
    char str_buffer[size + 1];
    memcpy(str_buffer, data, size);
    str_buffer[size] = '\0';

    /* Simple string search for imports (more sophisticated parsing would be better) */
    for (int i = 0; suspicious_imports[i] != NULL; i++) {
        if (strstr(str_buffer, suspicious_imports[i])) {
            count++;
        }
    }

    result->suspicious_imports_count = count;
    return count;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Heuristic Analysis
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_analyze_heuristics(phantom_antimalware_t *scanner,
                                            const char *filepath,
                                            uint8_t *file_data,
                                            size_t file_size,
                                            antimalware_scan_result_t *result) {
    if (!scanner || !filepath || !file_data || !result) return -1;

    result->heuristic_flags = HEURISTIC_NONE;

    /* Calculate entropy */
    result->entropy = phantom_antimalware_calculate_entropy(file_data, file_size);

    /* High entropy indicates encryption/packing */
    if (result->entropy > 7.0) {
        result->heuristic_flags |= HEURISTIC_HIGH_ENTROPY;
        result->threat_score += 20;
    }

    /* Check for packed executables */
    if (result->file_type == FILETYPE_ELF) {
        /* Check for UPX signature */
        if (file_size > 100 && strstr((char *)file_data, "UPX!")) {
            result->heuristic_flags |= HEURISTIC_PACKED;
            result->threat_score += 15;
        }

        /* Check suspicious imports */
        int imports = phantom_antimalware_check_elf_imports(file_data, file_size, result);
        if (imports > 5) {
            result->heuristic_flags |= HEURISTIC_SUSPICIOUS_IMPORT;
            result->threat_score += imports * 2;
        }
    }

    /* Check for suspicious strings */
    int strings = phantom_antimalware_check_strings(file_data, file_size, result);
    if (strings > 0) {
        if (strings >= 3) {
            result->heuristic_flags |= HEURISTIC_SHELL_SPAWN;
            result->threat_score += strings * 5;
        }

        /* Check specific patterns */
        char *str_data = (char *)file_data;

        if (strstr(str_data, "ptrace") || strstr(str_data, "PTRACE")) {
            result->heuristic_flags |= HEURISTIC_ANTI_DEBUG;
            result->threat_score += 15;
        }

        if (strstr(str_data, "VirtualBox") || strstr(str_data, "VMware") ||
            strstr(str_data, "QEMU")) {
            result->heuristic_flags |= HEURISTIC_ANTI_VM;
            result->threat_score += 10;
        }

        if (strstr(str_data, "YOUR FILES") || strstr(str_data, "ENCRYPTED") ||
            strstr(str_data, "bitcoin") || strstr(str_data, "ransom")) {
            result->heuristic_flags |= HEURISTIC_CRYPTO_STRINGS;
            result->threat_score += 40;
        }

        if (strstr(str_data, "keylog") || strstr(str_data, "GetAsyncKeyState")) {
            result->heuristic_flags |= HEURISTIC_KEYLOGGER;
            result->threat_score += 30;
        }

        if (strstr(str_data, "socket(") || strstr(str_data, "connect(")) {
            result->heuristic_flags |= HEURISTIC_NETWORK_ACCESS;
            result->threat_score += 5;
        }

        if (strstr(str_data, "/etc/cron") || strstr(str_data, ".bashrc") ||
            strstr(str_data, "systemctl")) {
            result->heuristic_flags |= HEURISTIC_PERSISTENCE;
            result->threat_score += 20;
        }

        if (strstr(str_data, "/etc/passwd") || strstr(str_data, "/etc/shadow") ||
            strstr(str_data, "id_rsa")) {
            result->heuristic_flags |= HEURISTIC_PASSWORD_THEFT;
            result->threat_score += 35;
        }
    }

    /* Check for double extension trick */
    const char *ext1 = strrchr(filepath, '.');
    if (ext1) {
        const char *ext2 = ext1 - 1;
        while (ext2 > filepath && *ext2 != '.') ext2--;
        if (*ext2 == '.' && ext2 != ext1) {
            /* Has double extension */
            if (strstr(ext2, ".pdf.") || strstr(ext2, ".doc.") ||
                strstr(ext2, ".jpg.") || strstr(ext2, ".png.")) {
                result->heuristic_flags |= HEURISTIC_HIDDEN_EXTENSION;
                result->threat_score += 25;
            }
        }
    }

    /* Determine threat level from score */
    if (result->threat_score >= 50) {
        result->threat_level = THREAT_SUSPICIOUS;
    }
    if (result->threat_score >= 70) {
        result->threat_level = THREAT_MALWARE;
    }

    return 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * File Scanning
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_scan_file(phantom_antimalware_t *scanner,
                                   const char *filepath,
                                   antimalware_scan_result_t *result,
                                   const antimalware_scan_options_t *options) {
    if (!scanner || !filepath || !result) return -1;

    const antimalware_scan_options_t *opts = options ? options : &scanner->default_options;

    memset(result, 0, sizeof(antimalware_scan_result_t));
    strncpy(result->filepath, filepath, sizeof(result->filepath) - 1);

    /* Extract filename */
    const char *filename = strrchr(filepath, '/');
    filename = filename ? filename + 1 : filepath;
    strncpy(result->filename, filename, sizeof(result->filename) - 1);

    /* Check if excluded */
    if (phantom_antimalware_is_excluded(scanner, filepath)) {
        result->scan_complete = 1;
        result->threat_level = THREAT_CLEAN;
        return 0;
    }

    /* Get file stats */
    struct stat st;
    if (stat(filepath, &st) != 0) {
        scanner->scan_errors++;
        return -1;
    }

    /* Skip directories */
    if (S_ISDIR(st.st_mode)) {
        return -1;
    }

    result->file_size = st.st_size;
    result->file_mtime = st.st_mtime;

    /* Check file size limit */
    if ((uint64_t)st.st_size > opts->max_file_size) {
        result->scan_complete = 1;
        result->threat_level = THREAT_CLEAN;
        snprintf(result->threat_description, sizeof(result->threat_description),
                 "File too large, skipped");
        return 0;
    }

    /* Read file */
    FILE *fp = fopen(filepath, "rb");
    if (!fp) {
        scanner->scan_errors++;
        return -1;
    }

    uint8_t *file_data = malloc(st.st_size);
    if (!file_data) {
        fclose(fp);
        scanner->scan_errors++;
        return -1;
    }

    size_t bytes_read = fread(file_data, 1, st.st_size, fp);
    fclose(fp);

    if (bytes_read != (size_t)st.st_size) {
        free(file_data);
        scanner->scan_errors++;
        return -1;
    }

    /* Detect file type */
    result->file_type = phantom_antimalware_detect_filetype(file_data, bytes_read, filename);

    /* Calculate hashes */
    phantom_antimalware_hash_data_md5(file_data, bytes_read, result->hash_md5);
    phantom_antimalware_hash_data_sha256(file_data, bytes_read, result->hash_sha256);

    /* Check signature database */
    antimalware_signature_t *sig = phantom_antimalware_lookup_hash(scanner, result->hash_sha256);
    if (sig) {
        result->threat_level = sig->threat_type;
        strncpy(result->threat_name, sig->threat_name, sizeof(result->threat_name) - 1);
        snprintf(result->threat_description, sizeof(result->threat_description),
                 "Known malware: %s", sig->threat_name);
        result->threat_score = 100;
        scanner->threats_found++;

        free(file_data);
        result->scan_complete = 1;
        scanner->files_scanned++;
        return 1;  /* Threat found */
    }

    /* Perform heuristic analysis if enabled */
    if (opts->heuristics_enabled && !opts->quick_scan) {
        phantom_antimalware_analyze_heuristics(scanner, filepath, file_data, bytes_read, result);

        if (result->threat_level >= THREAT_SUSPICIOUS) {
            scanner->threats_found++;
            free(file_data);
            result->scan_complete = 1;
            scanner->files_scanned++;
            return 1;  /* Suspicious file */
        }
    }

    free(file_data);
    result->scan_complete = 1;
    result->threat_level = THREAT_CLEAN;
    scanner->files_scanned++;
    return 0;  /* Clean */
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Directory Scanning
 * ───────────────────────────────────────────────────────────────────────────── */

static int scan_directory_recursive(phantom_antimalware_t *scanner,
                                    const char *dirpath,
                                    const antimalware_scan_options_t *opts,
                                    int depth) {
    if (!scanner || !dirpath) return -1;
    if (scanner->scan_cancelled) return 0;
    if (opts->max_depth > 0 && depth > opts->max_depth) return 0;

    DIR *dir = opendir(dirpath);
    if (!dir) return -1;

    struct dirent *entry;
    int threats_found = 0;
    char filepath[ANTIMALWARE_MAX_PATH];

    while ((entry = readdir(dir)) != NULL && !scanner->scan_cancelled) {
        /* Skip . and .. */
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        /* Skip hidden files if requested */
        if (!opts->scan_hidden && entry->d_name[0] == '.') {
            continue;
        }

        snprintf(filepath, sizeof(filepath), "%s/%s", dirpath, entry->d_name);

        struct stat st;
        if (lstat(filepath, &st) != 0) continue;

        /* Skip symlinks if not following */
        if (S_ISLNK(st.st_mode) && !opts->follow_symlinks) {
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            /* Recurse into directories */
            if (opts->recursive) {
                int sub_threats = scan_directory_recursive(scanner, filepath, opts, depth + 1);
                if (sub_threats > 0) threats_found += sub_threats;
            }
        } else if (S_ISREG(st.st_mode)) {
            /* Scan file */
            antimalware_scan_result_t result;

            /* Progress callback */
            if (opts->progress_callback) {
                opts->progress_callback(filepath, -1, opts->callback_userdata);
            }

            int scan_result = phantom_antimalware_scan_file(scanner, filepath, &result, opts);

            if (scan_result > 0) {
                threats_found++;
                scanner->current_scan_threats++;

                /* Threat callback */
                if (opts->threat_callback) {
                    opts->threat_callback(&result, opts->callback_userdata);
                }
            }

            scanner->current_scan_files++;
        }
    }

    closedir(dir);
    return threats_found;
}

int phantom_antimalware_scan_directory(phantom_antimalware_t *scanner,
                                        const char *dirpath,
                                        const antimalware_scan_options_t *options) {
    if (!scanner || !dirpath) return -1;

    const antimalware_scan_options_t *opts = options ? options : &scanner->default_options;

    scanner->scan_in_progress = 1;
    scanner->scan_cancelled = 0;
    scanner->current_scan_files = 0;
    scanner->current_scan_threats = 0;
    scanner->total_scans++;

    int threats = scan_directory_recursive(scanner, dirpath, opts, 0);

    scanner->scan_in_progress = 0;
    return threats;
}

int phantom_antimalware_quick_scan(phantom_antimalware_t *scanner,
                                    const antimalware_scan_options_t *options) {
    if (!scanner) return -1;

    antimalware_scan_options_t opts = options ? *options : scanner->default_options;
    opts.quick_scan = 1;  /* Signatures only */

    /* Scan common malware locations */
    const char *quick_scan_paths[] = {
        "/tmp",
        "/var/tmp",
        "/home",
        "/root",
        "/usr/local/bin",
        NULL
    };

    int total_threats = 0;

    for (int i = 0; quick_scan_paths[i] != NULL && !scanner->scan_cancelled; i++) {
        int threats = phantom_antimalware_scan_directory(scanner, quick_scan_paths[i], &opts);
        if (threats > 0) total_threats += threats;
    }

    return total_threats;
}

int phantom_antimalware_full_scan(phantom_antimalware_t *scanner,
                                   const antimalware_scan_options_t *options) {
    if (!scanner) return -1;

    return phantom_antimalware_scan_directory(scanner, "/", options);
}

void phantom_antimalware_cancel_scan(phantom_antimalware_t *scanner) {
    if (scanner) {
        scanner->scan_cancelled = 1;
    }
}

int phantom_antimalware_scan_active(phantom_antimalware_t *scanner) {
    return scanner ? scanner->scan_in_progress : 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Real-Time Monitoring
 * ───────────────────────────────────────────────────────────────────────────── */

static void *realtime_monitor_thread(void *arg) {
    phantom_antimalware_t *scanner = (phantom_antimalware_t *)arg;
    char buffer[INOTIFY_BUF_LEN];

    while (scanner->monitor_running) {
        int len = read(scanner->inotify_fd, buffer, INOTIFY_BUF_LEN);
        if (len < 0) {
            if (errno == EINTR) continue;
            break;
        }

        int i = 0;
        while (i < len) {
            struct inotify_event *event = (struct inotify_event *)&buffer[i];

            if (event->len > 0 && !(event->mask & IN_ISDIR)) {
                /* Find the watch path */
                pthread_mutex_lock(&scanner->monitor_lock);
                antimalware_watch_t *watch = scanner->watches;
                while (watch) {
                    if (watch->watch_descriptor == event->wd) break;
                    watch = watch->next;
                }
                pthread_mutex_unlock(&scanner->monitor_lock);

                if (watch) {
                    char filepath[ANTIMALWARE_MAX_PATH];
                    snprintf(filepath, sizeof(filepath), "%.3800s/%.256s", watch->path, event->name);

                    /* File was created or modified - scan it */
                    if (event->mask & (IN_CREATE | IN_MODIFY | IN_CLOSE_WRITE)) {
                        antimalware_scan_result_t result;
                        phantom_antimalware_scan_file(scanner, filepath, &result,
                                                       &scanner->default_options);

                        /* Auto-quarantine if threat found */
                        if (result.threat_level >= THREAT_MALWARE) {
                            phantom_antimalware_quarantine_file(scanner, filepath, &result);
                        }
                    }
                }
            }

            i += INOTIFY_EVENT_SIZE + event->len;
        }
    }

    return NULL;
}

int phantom_antimalware_start_realtime(phantom_antimalware_t *scanner) {
    if (!scanner || scanner->realtime_enabled) return -1;

    scanner->inotify_fd = inotify_init1(IN_NONBLOCK);
    if (scanner->inotify_fd < 0) return -1;

    scanner->monitor_running = 1;
    scanner->realtime_enabled = 1;

    if (pthread_create(&scanner->monitor_thread, NULL, realtime_monitor_thread, scanner) != 0) {
        close(scanner->inotify_fd);
        scanner->inotify_fd = -1;
        scanner->monitor_running = 0;
        scanner->realtime_enabled = 0;
        return -1;
    }

    return 0;
}

void phantom_antimalware_stop_realtime(phantom_antimalware_t *scanner) {
    if (!scanner || !scanner->realtime_enabled) return;

    scanner->monitor_running = 0;

    /* Close inotify to wake up the thread */
    if (scanner->inotify_fd >= 0) {
        close(scanner->inotify_fd);
        scanner->inotify_fd = -1;
    }

    pthread_join(scanner->monitor_thread, NULL);

    /* Free watches */
    pthread_mutex_lock(&scanner->monitor_lock);
    antimalware_watch_t *watch = scanner->watches;
    while (watch) {
        antimalware_watch_t *next = watch->next;
        free(watch);
        watch = next;
    }
    scanner->watches = NULL;
    pthread_mutex_unlock(&scanner->monitor_lock);

    scanner->realtime_enabled = 0;
}

int phantom_antimalware_watch_directory(phantom_antimalware_t *scanner,
                                         const char *dirpath, int recursive) {
    if (!scanner || !dirpath || !scanner->realtime_enabled) return -1;

    int wd = inotify_add_watch(scanner->inotify_fd, dirpath,
                               IN_CREATE | IN_MODIFY | IN_CLOSE_WRITE | IN_MOVED_TO);
    if (wd < 0) return -1;

    antimalware_watch_t *watch = malloc(sizeof(antimalware_watch_t));
    if (!watch) {
        inotify_rm_watch(scanner->inotify_fd, wd);
        return -1;
    }

    watch->watch_descriptor = wd;
    strncpy(watch->path, dirpath, sizeof(watch->path) - 1);
    watch->path[sizeof(watch->path) - 1] = '\0';
    watch->recursive = recursive;

    pthread_mutex_lock(&scanner->monitor_lock);
    watch->next = scanner->watches;
    scanner->watches = watch;
    pthread_mutex_unlock(&scanner->monitor_lock);

    /* Add subdirectories if recursive */
    if (recursive) {
        DIR *dir = opendir(dirpath);
        if (dir) {
            struct dirent *entry;
            char subpath[ANTIMALWARE_MAX_PATH];

            while ((entry = readdir(dir)) != NULL) {
                if (entry->d_name[0] == '.') continue;

                snprintf(subpath, sizeof(subpath), "%s/%s", dirpath, entry->d_name);

                struct stat st;
                if (stat(subpath, &st) == 0 && S_ISDIR(st.st_mode)) {
                    phantom_antimalware_watch_directory(scanner, subpath, 1);
                }
            }
            closedir(dir);
        }
    }

    return 0;
}

int phantom_antimalware_unwatch_directory(phantom_antimalware_t *scanner,
                                           const char *dirpath) {
    if (!scanner || !dirpath || !scanner->realtime_enabled) return -1;

    pthread_mutex_lock(&scanner->monitor_lock);

    antimalware_watch_t *prev = NULL;
    antimalware_watch_t *watch = scanner->watches;

    while (watch) {
        if (strcmp(watch->path, dirpath) == 0) {
            inotify_rm_watch(scanner->inotify_fd, watch->watch_descriptor);

            if (prev) {
                prev->next = watch->next;
            } else {
                scanner->watches = watch->next;
            }

            free(watch);
            pthread_mutex_unlock(&scanner->monitor_lock);
            return 0;
        }
        prev = watch;
        watch = watch->next;
    }

    pthread_mutex_unlock(&scanner->monitor_lock);
    return -1;
}

int phantom_antimalware_realtime_active(phantom_antimalware_t *scanner) {
    return scanner ? scanner->realtime_enabled : 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Quarantine Functions
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_set_quarantine_path(phantom_antimalware_t *scanner,
                                             const char *path) {
    if (!scanner || !path) return -1;

    strncpy(scanner->quarantine_path, path, sizeof(scanner->quarantine_path) - 1);
    scanner->quarantine_path[sizeof(scanner->quarantine_path) - 1] = '\0';

    /* Create directory if it doesn't exist */
    mkdir(scanner->quarantine_path, 0700);

    return 0;
}

int phantom_antimalware_quarantine_file(phantom_antimalware_t *scanner,
                                         const char *filepath,
                                         const antimalware_scan_result_t *result) {
    if (!scanner || !filepath || !result) return -1;

    /* Create quarantine entry */
    antimalware_quarantine_entry_t *entry = malloc(sizeof(antimalware_quarantine_entry_t));
    if (!entry) return -1;

    strncpy(entry->original_path, filepath, sizeof(entry->original_path) - 1);
    strncpy(entry->threat_name, result->threat_name, sizeof(entry->threat_name) - 1);
    strncpy(entry->hash_sha256, result->hash_sha256, sizeof(entry->hash_sha256) - 1);
    entry->threat_type = result->threat_level;
    entry->file_size = result->file_size;
    entry->quarantine_time = time(NULL);

    /* Generate quarantine path */
    snprintf(entry->quarantine_path, sizeof(entry->quarantine_path),
             "%.3900s/%.64s_%lu%s", scanner->quarantine_path,
             result->hash_sha256, (unsigned long)entry->quarantine_time,
             ANTIMALWARE_QUARANTINE_EXT);

    /* Create quarantine directory */
    mkdir(scanner->quarantine_path, 0700);

    /* Move file to quarantine (rename or copy+delete) */
    if (rename(filepath, entry->quarantine_path) != 0) {
        /* Try copy + delete */
        FILE *src = fopen(filepath, "rb");
        FILE *dst = fopen(entry->quarantine_path, "wb");

        if (src && dst) {
            uint8_t buffer[8192];
            size_t bytes;
            while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                fwrite(buffer, 1, bytes, dst);
            }
            fclose(src);
            fclose(dst);
            unlink(filepath);
        } else {
            if (src) fclose(src);
            if (dst) fclose(dst);
            free(entry);
            return -1;
        }
    }

    /* Add to quarantine list */
    pthread_mutex_lock(&scanner->quarantine_lock);
    entry->next = scanner->quarantine_list;
    scanner->quarantine_list = entry;
    scanner->quarantine_count++;
    scanner->files_quarantined++;
    pthread_mutex_unlock(&scanner->quarantine_lock);

    return 0;
}

int phantom_antimalware_restore_file(phantom_antimalware_t *scanner,
                                      const char *quarantine_path) {
    if (!scanner || !quarantine_path) return -1;

    pthread_mutex_lock(&scanner->quarantine_lock);

    antimalware_quarantine_entry_t *prev = NULL;
    antimalware_quarantine_entry_t *entry = scanner->quarantine_list;

    while (entry) {
        if (strcmp(entry->quarantine_path, quarantine_path) == 0) {
            /* Restore the file */
            if (rename(entry->quarantine_path, entry->original_path) != 0) {
                pthread_mutex_unlock(&scanner->quarantine_lock);
                return -1;
            }

            /* Remove from list */
            if (prev) {
                prev->next = entry->next;
            } else {
                scanner->quarantine_list = entry->next;
            }

            scanner->quarantine_count--;
            free(entry);

            pthread_mutex_unlock(&scanner->quarantine_lock);
            return 0;
        }
        prev = entry;
        entry = entry->next;
    }

    pthread_mutex_unlock(&scanner->quarantine_lock);
    return -1;
}

int phantom_antimalware_delete_quarantined(phantom_antimalware_t *scanner,
                                            const char *quarantine_path) {
    if (!scanner || !quarantine_path) return -1;

    pthread_mutex_lock(&scanner->quarantine_lock);

    antimalware_quarantine_entry_t *prev = NULL;
    antimalware_quarantine_entry_t *entry = scanner->quarantine_list;

    while (entry) {
        if (strcmp(entry->quarantine_path, quarantine_path) == 0) {
            /* Delete the file */
            unlink(entry->quarantine_path);

            /* Remove from list */
            if (prev) {
                prev->next = entry->next;
            } else {
                scanner->quarantine_list = entry->next;
            }

            scanner->quarantine_count--;
            free(entry);

            pthread_mutex_unlock(&scanner->quarantine_lock);
            return 0;
        }
        prev = entry;
        entry = entry->next;
    }

    pthread_mutex_unlock(&scanner->quarantine_lock);
    return -1;
}

antimalware_quarantine_entry_t *phantom_antimalware_list_quarantine(
    phantom_antimalware_t *scanner) {
    return scanner ? scanner->quarantine_list : NULL;
}

uint32_t phantom_antimalware_get_quarantine_count(phantom_antimalware_t *scanner) {
    return scanner ? scanner->quarantine_count : 0;
}

int phantom_antimalware_empty_quarantine(phantom_antimalware_t *scanner) {
    if (!scanner) return -1;

    pthread_mutex_lock(&scanner->quarantine_lock);

    antimalware_quarantine_entry_t *entry = scanner->quarantine_list;
    while (entry) {
        antimalware_quarantine_entry_t *next = entry->next;
        unlink(entry->quarantine_path);
        free(entry);
        entry = next;
    }

    scanner->quarantine_list = NULL;
    scanner->quarantine_count = 0;

    pthread_mutex_unlock(&scanner->quarantine_lock);
    return 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Exclusion Functions
 * ───────────────────────────────────────────────────────────────────────────── */

int phantom_antimalware_add_exclusion(phantom_antimalware_t *scanner,
                                       const char *path) {
    if (!scanner || !path) return -1;

    /* Expand capacity if needed */
    if (scanner->exclusion_count >= scanner->exclusion_capacity) {
        uint32_t new_cap = scanner->exclusion_capacity ? scanner->exclusion_capacity * 2 : 16;
        char **new_list = realloc(scanner->exclusion_paths, new_cap * sizeof(char *));
        if (!new_list) return -1;
        scanner->exclusion_paths = new_list;
        scanner->exclusion_capacity = new_cap;
    }

    scanner->exclusion_paths[scanner->exclusion_count] = strdup(path);
    if (!scanner->exclusion_paths[scanner->exclusion_count]) return -1;

    scanner->exclusion_count++;
    return 0;
}

int phantom_antimalware_remove_exclusion(phantom_antimalware_t *scanner,
                                          const char *path) {
    if (!scanner || !path) return -1;

    for (uint32_t i = 0; i < scanner->exclusion_count; i++) {
        if (strcmp(scanner->exclusion_paths[i], path) == 0) {
            free(scanner->exclusion_paths[i]);

            /* Shift remaining entries */
            for (uint32_t j = i; j < scanner->exclusion_count - 1; j++) {
                scanner->exclusion_paths[j] = scanner->exclusion_paths[j + 1];
            }

            scanner->exclusion_count--;
            return 0;
        }
    }

    return -1;
}

int phantom_antimalware_is_excluded(phantom_antimalware_t *scanner,
                                     const char *filepath) {
    if (!scanner || !filepath) return 0;

    for (uint32_t i = 0; i < scanner->exclusion_count; i++) {
        /* Check if filepath starts with exclusion path */
        if (strncmp(filepath, scanner->exclusion_paths[i],
                    strlen(scanner->exclusion_paths[i])) == 0) {
            return 1;
        }
    }

    return 0;
}

void phantom_antimalware_clear_exclusions(phantom_antimalware_t *scanner) {
    if (!scanner) return;

    for (uint32_t i = 0; i < scanner->exclusion_count; i++) {
        free(scanner->exclusion_paths[i]);
    }

    free(scanner->exclusion_paths);
    scanner->exclusion_paths = NULL;
    scanner->exclusion_count = 0;
    scanner->exclusion_capacity = 0;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Statistics and Utility Functions
 * ───────────────────────────────────────────────────────────────────────────── */

void phantom_antimalware_get_stats(phantom_antimalware_t *scanner,
                                    uint64_t *total_scans,
                                    uint64_t *files_scanned,
                                    uint64_t *threats_found,
                                    uint64_t *files_quarantined) {
    if (!scanner) return;
    if (total_scans) *total_scans = scanner->total_scans;
    if (files_scanned) *files_scanned = scanner->files_scanned;
    if (threats_found) *threats_found = scanner->threats_found;
    if (files_quarantined) *files_quarantined = scanner->files_quarantined;
}

void phantom_antimalware_reset_stats(phantom_antimalware_t *scanner) {
    if (!scanner) return;
    scanner->total_scans = 0;
    scanner->files_scanned = 0;
    scanner->threats_found = 0;
    scanner->files_quarantined = 0;
    scanner->scan_errors = 0;
    scanner->total_scan_time_ms = 0;
}

const char *phantom_antimalware_threat_str(antimalware_threat_t level) {
    switch (level) {
        case THREAT_CLEAN:       return "Clean";
        case THREAT_SUSPICIOUS:  return "Suspicious";
        case THREAT_MALWARE:     return "Malware";
        case THREAT_RANSOMWARE:  return "Ransomware";
        case THREAT_TROJAN:      return "Trojan";
        case THREAT_VIRUS:       return "Virus";
        case THREAT_WORM:        return "Worm";
        case THREAT_ROOTKIT:     return "Rootkit";
        case THREAT_ADWARE:      return "Adware/PUP";
        case THREAT_SPYWARE:     return "Spyware";
        case THREAT_CRYPTOMINER: return "Cryptominer";
        case THREAT_BACKDOOR:    return "Backdoor/RAT";
        default:                 return "Unknown";
    }
}

const char *phantom_antimalware_threat_icon(antimalware_threat_t level) {
    switch (level) {
        case THREAT_CLEAN:       return "[OK]";
        case THREAT_SUSPICIOUS:  return "[?]";
        case THREAT_MALWARE:     return "[!]";
        case THREAT_RANSOMWARE:  return "[!!]";
        case THREAT_TROJAN:      return "[T]";
        case THREAT_VIRUS:       return "[V]";
        case THREAT_WORM:        return "[W]";
        case THREAT_ROOTKIT:     return "[R]";
        case THREAT_ADWARE:      return "[A]";
        case THREAT_SPYWARE:     return "[S]";
        case THREAT_CRYPTOMINER: return "[C]";
        case THREAT_BACKDOOR:    return "[B]";
        default:                 return "[?]";
    }
}

const char *phantom_antimalware_filetype_str(antimalware_filetype_t type) {
    switch (type) {
        case FILETYPE_ELF:          return "ELF Executable";
        case FILETYPE_PE:           return "Windows Executable";
        case FILETYPE_MACHO:        return "macOS Executable";
        case FILETYPE_SCRIPT_SHELL: return "Shell Script";
        case FILETYPE_SCRIPT_PYTHON: return "Python Script";
        case FILETYPE_SCRIPT_PERL:  return "Perl Script";
        case FILETYPE_SCRIPT_PHP:   return "PHP Script";
        case FILETYPE_SCRIPT_JS:    return "JavaScript";
        case FILETYPE_PDF:          return "PDF Document";
        case FILETYPE_OFFICE_DOC:   return "Office Document";
        case FILETYPE_OFFICE_DOCX:  return "Office XML Document";
        case FILETYPE_ZIP:          return "ZIP Archive";
        case FILETYPE_GZIP:         return "Gzip Archive";
        case FILETYPE_TAR:          return "TAR Archive";
        case FILETYPE_RAR:          return "RAR Archive";
        case FILETYPE_7ZIP:         return "7-Zip Archive";
        case FILETYPE_ISO:          return "ISO Image";
        case FILETYPE_JAR:          return "Java Archive";
        case FILETYPE_APK:          return "Android Package";
        case FILETYPE_DEB:          return "Debian Package";
        case FILETYPE_RPM:          return "RPM Package";
        case FILETYPE_IMAGE:        return "Image File";
        case FILETYPE_AUDIO:        return "Audio File";
        case FILETYPE_VIDEO:        return "Video File";
        case FILETYPE_TEXT:         return "Text File";
        case FILETYPE_HTML:         return "HTML Document";
        case FILETYPE_XML:          return "XML Document";
        case FILETYPE_JSON:         return "JSON Data";
        default:                    return "Unknown";
    }
}

void phantom_antimalware_format_heuristics(uint32_t flags, char *buf, size_t size) {
    if (!buf || size == 0) return;
    buf[0] = '\0';

    struct {
        uint32_t flag;
        const char *name;
    } flag_names[] = {
        {HEURISTIC_PACKED, "Packed"},
        {HEURISTIC_HIGH_ENTROPY, "High Entropy"},
        {HEURISTIC_SUSPICIOUS_IMPORT, "Suspicious Imports"},
        {HEURISTIC_HIDDEN_EXTENSION, "Hidden Extension"},
        {HEURISTIC_OBFUSCATED, "Obfuscated"},
        {HEURISTIC_SHELL_SPAWN, "Shell Spawn"},
        {HEURISTIC_NETWORK_ACCESS, "Network Access"},
        {HEURISTIC_FILE_DROPPER, "File Dropper"},
        {HEURISTIC_PERSISTENCE, "Persistence"},
        {HEURISTIC_PRIVILEGE_ESCALATION, "Privilege Escalation"},
        {HEURISTIC_ANTI_DEBUG, "Anti-Debug"},
        {HEURISTIC_ANTI_VM, "Anti-VM"},
        {HEURISTIC_CRYPTO_STRINGS, "Crypto Strings"},
        {HEURISTIC_KEYLOGGER, "Keylogger"},
        {HEURISTIC_SCREEN_CAPTURE, "Screen Capture"},
        {HEURISTIC_WEBCAM_ACCESS, "Webcam Access"},
        {HEURISTIC_PASSWORD_THEFT, "Password Theft"},
        {HEURISTIC_SUSPICIOUS_PERMS, "Suspicious Permissions"},
        {HEURISTIC_SCRIPT_IN_BINARY, "Script in Binary"},
        {0, NULL}
    };

    size_t pos = 0;
    int first = 1;

    for (int i = 0; flag_names[i].name != NULL; i++) {
        if (flags & flag_names[i].flag) {
            int len = snprintf(buf + pos, size - pos, "%s%s",
                              first ? "" : ", ", flag_names[i].name);
            if (len > 0 && pos + len < size) {
                pos += len;
                first = 0;
            }
        }
    }

    if (first) {
        strncpy(buf, "None", size - 1);
        buf[size - 1] = '\0';
    }
}
